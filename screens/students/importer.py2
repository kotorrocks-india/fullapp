# app/screens/students/importer.py
# -------------------------------------------------------------------
# All Student Import/Export, Credential, and Mover functions
# WITH BETTER ERROR HANDLING (NO DEBUG, PRODUCTION READY)
# -------------------------------------------------------------------

from __future__ import annotations

from typing import List, Tuple, Dict, Any, Optional, Set
from dataclasses import dataclass, field
import pandas as pd
import streamlit as st
from sqlalchemy import text as sa_text
from sqlalchemy.engine import Engine, Connection
from collections import defaultdict
import logging
import traceback

# Import common helpers
from screens.faculty.utils import _safe_int_convert, _handle_error
from screens.faculty.db import _active_degrees

# --- Import from student db.py file ---
from screens.students.db import (
    _ensure_student_username_and_initial_creds,
    _get_student_credentials_to_export,
    _get_existing_enrollment_data,
    _db_get_batches_for_degree,
    _db_get_students_for_mover,
    _db_move_students
)

# Setup logger
log = logging.getLogger(__name__)


# ------------------------------------------------------------------
# Helpers for Stateful Import (Batch/Year Validation)
# ------------------------------------------------------------------

@dataclass
class EnrollmentCheckResult:
    """Holds the data from pre-checking student enrollments."""
    unmatched_batches: Set[str] = field(default_factory=set)
    existing_batches: List[str] = field(default_factory=list)
    unmatched_years: Set[str] = field(default_factory=set)
    existing_years: List[str] = field(default_factory=list)
    ignored_rows: int = 0


def _pre_check_student_enrollments(df: pd.DataFrame, engine: Engine, degree_code: str) -> Tuple[EnrollmentCheckResult, pd.DataFrame]:
    """
    Compares the CSV data against the database for a single degree
    to find unmatched batches and years.
    """
    degree_code_clean = degree_code.strip()

    # 1. Clean and Filter DataFrame
    for col in ['degree_code', 'batch', 'current_year']:
        if col in df.columns:
            df[col] = df[col].astype(str).str.strip().replace('nan', '')

    df_filtered = df[df['degree_code'].str.lower() == degree_code_clean.lower()].copy()
    ignored_rows = len(df) - len(df_filtered)

    if df_filtered.empty:
        raise ValueError(f"No rows found in the CSV for the selected degree '{degree_code_clean}'.")

    # 2. Get unique codes from the *filtered* CSV
    csv_batches = set(df_filtered['batch'].dropna().unique()) - {''}
    csv_years = set(df_filtered['current_year'].dropna().unique()) - {''}

    # 3. Get existing codes from the DB
    existing_data = _get_existing_enrollment_data(engine, degree_code_clean)

    db_batches = set(existing_data['batches'])
    db_years = set(existing_data['years'])

    # 4. Find the mismatches
    result = EnrollmentCheckResult(
        unmatched_batches=csv_batches - db_batches,
        existing_batches=sorted(list(db_batches)),
        unmatched_years=csv_years - db_years,
        existing_years=sorted(list(db_years)),
        ignored_rows=ignored_rows
    )

    return result, df_filtered


def _build_translation_map(
    mappings: Dict[str, Dict[str, str]]
) -> Dict[str, Dict[str, str]]:
    """
    Converts the raw UI mappings into a clean translation map
    for the import function.
    """
    translation_map = {}
    for aff_type, type_mappings in mappings.items():
        translation_map[aff_type] = {}
        for code, action in type_mappings.items():
            if action == "[USE_NEW]":
                translation_map[aff_type][code] = code
            else:
                translation_map[aff_type][code] = action

    return translation_map


# ------------------------------------------------------------------
# Main Import Logic
# ------------------------------------------------------------------

def _show_no_degrees_help(engine: Engine, context: str = "student operations"):
    """
    Shows a helpful setup guide when no degrees exist.
    Returns True if degrees exist, False otherwise.
    """
    with engine.begin() as conn:
        degrees = _active_degrees(conn)
        if degrees:
            return True

    # No degrees found - show setup guide
    st.warning(f"‚ö†Ô∏è No degrees found. You need to set up degrees before performing {context}.")
    st.markdown("""
### üöÄ Getting Started

To import students, you need to first create the academic structure:

1. **Create Degrees** (e.g., BTech, MTech, MBA)

2. *(Optional)* Create Programs and Branches

3. **Import Students** using the CSV template

""")

    with st.expander("‚ûï Quick Create Your First Degree", expanded=True):
        st.info("Create a degree to unlock student import functionality.")
        col1, col2 = st.columns(2)

        with col1:
            degree_code = st.text_input(
                "Degree Code*",
                placeholder="e.g., BTech, MTech",
                key=f"quick_degree_code_{context}"
            )

        with col2:
            degree_name = st.text_input(
                "Degree Name (optional)",
                placeholder="e.g., Bachelor of Technology",
                key=f"quick_degree_name_{context}"
            )

        if st.button("‚ú® Create Degree", type="primary", key=f"create_degree_{context}"):
            if not degree_code or not degree_code.strip():
                st.error("‚ùå Degree code is required")
            else:
                try:
                    with engine.begin() as conn:
                        # Check if degree already exists
                        existing = conn.execute(sa_text(
                            "SELECT 1 FROM degrees WHERE LOWER(code) = LOWER(:code)"
                        ), {"code": degree_code.strip()}).fetchone()

                        if existing:
                            st.error(f"‚ùå Degree '{degree_code}' already exists")
                        else:
                            conn.execute(sa_text("""
                                INSERT INTO degrees (code, name, active, sort_order, created_at, updated_at)
                                VALUES (:code, :name, 1, 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
                            """), {
                                "code": degree_code.strip(),
                                "name": degree_name.strip() or degree_code.strip()
                            })
                            st.success(f"‚úÖ Created degree: **{degree_code}**")
                            st.cache_data.clear()
                            st.balloons()
                            st.rerun()
                except Exception as e:
                    st.error(f"‚ùå Failed to create degree: {e}")
                    log.error(f"Degree creation failed: {e}")

    st.divider()
    st.info("üí° **Alternative:** If you have a dedicated Degrees management page, you can create degrees there with more options.")
    return False


def _import_students_with_validation(
    engine: Engine,
    df: pd.DataFrame,
    dry_run: bool,
    mappings: Optional[Dict[str, Dict[str, str]]] = None,
    conn_for_transaction: Optional[Connection] = None
) -> Tuple[List[Dict[str, Any]], int, List[Dict[str, Any]]]:
    """
    Import combined student profiles and enrollments with validation.
    RETURNS: (errors, success_count, skipped_rows)
    """
    df.columns = [col.lower().strip().replace(' ', '_') for col in df.columns]
    errors: List[Dict[str, Any]] = []
    skipped_rows: List[Dict[str, Any]] = []
    success_count = 0
    translation_map = _build_translation_map(mappings) if mappings else {}

    # Metadata fetch
    with engine.begin() as meta_conn:
        all_degrees = _active_degrees(meta_conn)

    # Transaction logic
    if conn_for_transaction:
        conn = conn_for_transaction
        trans = conn.begin_nested()
        should_close = False
    else:
        conn = engine.connect()
        trans = conn.begin()
        should_close = True

    try:
        for idx, row in df.iterrows():
            row_num = idx + 2
            try:
                # 1. Validate Profile Data
                email = str(row.get('email', '')).strip().lower()
                student_id = str(row.get('student_id', '')).strip()
                name = str(row.get('name', '')).strip()

                if not name or not email or not student_id:
                    errors.append({'row': row_num, 'email': email, 'error': "Missing required fields: name, email, and student_id"})
                    continue

                # 2. Upsert Profile
                profile_id = conn.execute(sa_text(
                    "SELECT id FROM student_profiles WHERE student_id = :sid"
                ), {"sid": student_id}).fetchone()

                if profile_id:
                    profile_id = profile_id[0]
                    conn.execute(sa_text("""
                        UPDATE student_profiles
                        SET name = :name, email = :email, phone = :phone, status = :status,
                        updated_at = CURRENT_TIMESTAMP
                        WHERE id = :id
                    """), {
                        "name": name, "email": email, "phone": row.get('phone'),
                        "status": row.get('status', 'active'), "id": profile_id
                    })
                else:
                    res = conn.execute(sa_text("""
                        INSERT INTO student_profiles (name, email, student_id, phone, status)
                        VALUES (:name, :email, :sid, :phone, :status)
                        RETURNING id
                    """), {
                        "name": name, "email": email, "sid": student_id,
                        "phone": row.get('phone'), "status": row.get('status', 'active')
                    })
                    profile_id = res.fetchone()[0]

                # 3. Ensure Credentials Exist
                _ensure_student_username_and_initial_creds(
                    conn, profile_id, email, name, student_id
                )

                # 4. Process Enrollment
                degree_code = str(row.get('degree_code', '')).strip()

                if degree_code:
                    if degree_code not in all_degrees:
                        errors.append({'row': row_num, 'email': email, 'error': f"Degree '{degree_code}' not found."})
                        continue

                    batch = str(row.get('batch', '')).strip()
                    current_year = str(row.get('current_year', '')).strip()

                    if not batch or not current_year:
                        errors.append({'row': row_num, 'email': email, 'error': "Missing 'batch' or 'current_year' for enrollment."})
                        continue

                    # Apply mappings
                    mapped_batch = translation_map.get('batch', {}).get(batch, batch)
                    mapped_year = translation_map.get('year', {}).get(current_year, current_year)

                    # Check for [IGNORE]
                    if mapped_batch == "[IGNORE]" or mapped_year == "[IGNORE]":
                        log.debug(f"Row {row_num}: Ignoring enrollment due to user mapping.")
                        skipped_rows.append({
                            "row": row_num, "email": email, "reason": "Ignored by user mapping rule."
                        })
                        continue

                    program_code = str(row.get('program_code', '')).strip() or None
                    branch_code = str(row.get('branch_code', '')).strip() or None

                    # Upsert Enrollment
                    enrollment_id = conn.execute(sa_text("""
                        SELECT id FROM student_enrollments
                        WHERE student_profile_id = :pid AND degree_code = :degree AND batch = :batch
                    """), {
                        "pid": profile_id, "degree": degree_code, "batch": mapped_batch
                    }).fetchone()

                    if enrollment_id:
                        conn.execute(sa_text("""
                            UPDATE student_enrollments
                            SET program_code = :prog, branch_code = :branch,
                            current_year = :year, enrollment_status = :status,
                            updated_at = CURRENT_TIMESTAMP
                            WHERE id = :id
                        """), {
                            "prog": program_code, "branch": branch_code,
                            "year": mapped_year, "status": row.get('enrollment_status', 'active'),
                            "id": enrollment_id[0]
                        })
                    else:
                        conn.execute(sa_text("""
                            INSERT INTO student_enrollments (
                            student_profile_id, degree_code, program_code, branch_code,
                            batch, current_year, enrollment_status, is_primary
                            ) VALUES (
                            :pid, :degree, :prog, :branch,
                            :batch, :year, :status, 1
                            )
                        """), {
                            "pid": profile_id, "degree": degree_code, "prog": program_code, "branch": branch_code,
                            "batch": mapped_batch, "year": mapped_year,
                            "status": row.get('enrollment_status', 'active')
                        })

                success_count += 1

            except Exception as e:
                errors.append({'row': row_num, 'email': str(row.get('email', '')).strip().lower(), 'error': str(e)})

        if dry_run:
            trans.rollback()
        else:
            trans.commit()

    except Exception:
        if trans:
            trans.rollback()
        raise

    finally:
        if should_close:
            conn.close()

    return errors, success_count, skipped_rows


# ------------------------------------------------------------------
# STATEFUL IMPORT UI
# ------------------------------------------------------------------

def _reset_student_import_state():
    """Resets the session state for the student import wizard."""
    st.session_state.student_import_step = 'initial'
    st.session_state.student_import_mappings = {}
    st.session_state.student_import_validation_data = None
    st.session_state.student_import_df = None
    log.debug("Resetting student import state.")


def _add_student_import_export_section(engine: Engine):
    """
    UI for managing student import/export, including stateful
    validation for Batches and Years with BETTER ERROR HANDLING.
    """
    st.divider()
    st.subheader("üî•üì§ Combined Student Import/Export")

    if not _show_no_degrees_help(engine, "student import"):
        return

    # State Initialization
    if 'student_import_step' not in st.session_state:
        _reset_student_import_state()

    # Select Degree
    with engine.begin() as conn:
        degrees = _active_degrees(conn)
        if not degrees:
            st.error("‚ùå No degrees available. Please create degrees first.")
            st.info("üí° **Next Steps:**\n"
                    "1. Navigate to the **Degrees** or **Settings** page\n"
                    "2. Create at least one degree (e.g., 'BTech', 'MTech')\n"
                    "3. Return here to import students")
            return

    if st.session_state.get('student_import_degree'):
        selected_degree = st.session_state.student_import_degree
        st.info(f"üìã **Selected Degree:** `{selected_degree}`")
    else:
        selected_degree_raw = st.selectbox("Select Degree for Student Import", options=degrees, key="degree_selector_student")

        if st.button("Confirm Degree Selection", type="primary"):
            st.session_state.student_import_degree = selected_degree_raw.strip()
            st.rerun()

        st.warning("‚ö†Ô∏è Please confirm your degree selection to proceed with import.")
        return

    # Export Section
    with st.expander("üì• Export Student Data / Templates"):
        st.download_button(
            label="Download Combined Student Template",
            data="name,email,student_id,phone,status,degree_code,program_code,branch_code,batch,current_year,enrollment_status",
            file_name="student_combined_template.csv",
            mime="text/csv"
        )

    # File Uploader
    st.markdown("### üì§ Import Student Data")
    up = st.file_uploader("Upload Combined Student CSV", type="csv", key="student_uploader")

    if st.session_state.student_import_step != 'initial':
        if st.button("üîÑ Cancel Import & Start Over", key="cancel_student_import"):
            _reset_student_import_state()
            st.rerun()

    st.divider()

    # State: Initial (Validation)
    if st.session_state.student_import_step == 'initial':
        st.markdown("#### Step 1: Validate File")

        if not up:
            st.warning("Please upload a CSV file to begin.")
            if 'student_import_df' in st.session_state:
                _reset_student_import_state()
            return

        if st.button("üîç Validate File", type="primary"):
            try:
                up.seek(0)
                df = pd.read_csv(up)

                with st.spinner("Validating CSV for new batches and years..."):
                    try:
                        validation_data, filtered_df = _pre_check_student_enrollments(df, engine, selected_degree)
                    except ValueError as ve:
                        # ‚úÖ CATCH VALIDATION ERRORS - SHOW SPECIFIC MESSAGE
                        error_msg = str(ve)
                        
                        st.error(f"""
### ‚ùå Validation Failed

**Error:** {error_msg}

**Why This Happened:**

Your CSV file does not contain any rows with `degree_code = {selected_degree}`

**Common Causes:**

1Ô∏è‚É£ **Degree code column is empty** 
   - The `degree_code` column in your CSV is completely empty
   - Every row needs a value here

2Ô∏è‚É£ **Degree code doesn't match**
   - You selected: **{selected_degree}**
   - But your CSV has different values (or none)

3Ô∏è‚É£ **Wrong degree selected**
   - You selected the wrong degree
   - Change the degree selection to match your CSV data

**How to Fix:**

1. Open your CSV file in Excel or Google Sheets
2. Find the `degree_code` column
3. Fill it with: `{selected_degree}` (for ALL rows)
4. Save as CSV
5. Upload again

**Example CSV (first 3 rows):**
```
name,email,student_id,phone,status,degree_code,batch,current_year
ANSARI MISBA,s202101@institution.edu,202101,,active,{selected_degree},2021,5
BALCHANDANI GUNJAN,s202102@institution.edu,202102,,active,{selected_degree},2021,5
BHISE ADITYA,s202103@institution.edu,202103,,active,{selected_degree},2021,5
```
                        """)
                        log.warning(f"Validation failed: {error_msg}")
                        return
                        
                    except Exception as inner_e:
                        # ‚úÖ CATCH OTHER ERRORS - SHOW WHAT WENT WRONG
                        tb_str = traceback.format_exc()
                        
                        st.error(f"""
### ‚ùå Validation Error

**Error Type:** {type(inner_e).__name__}

**Error Message:** {str(inner_e)}

**What Happened:** An unexpected error occurred while validating your CSV file.

**Possible Causes:**
- CSV file is corrupted or incomplete
- Invalid data format in one of the columns
- Missing required columns (name, email, student_id, degree_code, batch, current_year)
- Database connection issue

**Troubleshooting Steps:**

1. **Check CSV Format**
   - Open in Excel and verify all required columns exist
   - Verify data types are correct
   - Ensure no special characters in values

2. **Verify Required Columns**
   - name ‚úì
   - email ‚úì
   - student_id ‚úì
   - degree_code ‚úì
   - batch ‚úì
   - current_year ‚úì

3. **Test with Small CSV**
   - Try uploading a CSV with just 2-3 rows
   - If that works, your original file has data issues

4. **Contact Support**
   - Share error details if issue persists
                        """)
                        log.error(f"Unexpected validation error: {tb_str}")
                        return

                st.session_state.student_import_validation_data = validation_data
                st.session_state.student_import_df = filtered_df
                st.session_state.student_import_mappings = {"batch": {}, "year": {}}

                if validation_data.ignored_rows > 0:
                    st.info(f"‚úÖ Found {len(filtered_df)} rows for degree '{selected_degree}'. "
                            f"{validation_data.ignored_rows} rows for other degrees will be ignored.")

                if validation_data.unmatched_batches:
                    st.session_state.student_import_step = 'map_batches'
                elif validation_data.unmatched_years:
                    st.session_state.student_import_step = 'map_years'
                else:
                    st.session_state.student_import_step = 'ready_to_import'

                st.rerun()

            except pd.errors.ParserError as pe:
                # ‚úÖ CSV PARSING ERROR
                st.error(f"""
### ‚ùå CSV File Format Error

**Error:** {str(pe)}

**What Happened:** The file you uploaded is not a valid CSV file or is corrupted.

**How to Fix:**

1. **Re-save as CSV**
   - Open your file in Excel
   - Click File ‚Üí Save As
   - Choose "CSV UTF-8 (.csv)"

2. **Check File Format**
   - Make sure file extension is .csv
   - Don't upload Excel files (.xlsx)

3. **Use Template**
   - Download the CSV template from the Export button
   - Fill with your data
   - Upload
                """)
                log.warning(f"CSV parsing error: {pe}")
                return
                
            except Exception as e:
                # ‚úÖ UNEXPECTED ERROR
                tb_str = traceback.format_exc()
                
                st.error(f"""
### ‚ùå Unexpected Error During File Validation

**Error Type:** {type(e).__name__}

**Error Message:** {str(e)}

**Troubleshooting:**

1. Clear cache and refresh (F5)
2. Try uploading again
3. Use the CSV template from the Export button
4. Contact support if issue persists
                """)
                log.error(f"Unexpected file validation error: {tb_str}")
                return

    # State: Map Batches
    elif st.session_state.student_import_step == 'map_batches':
        st.markdown("#### Step 2: Map Batches")
        st.warning(f"‚ö†Ô∏è Your file contains Batches that are not in the database for **{selected_degree}**.")

        data: EnrollmentCheckResult = st.session_state.student_import_validation_data
        options = ["[Select Action]"] + data.existing_batches + ["[-- Use New Batch --]", "[-- Ignore These Rows --]"]

        valid = True
        col1, col2 = st.columns([1, 2])

        col1.markdown("**CSV Value**")
        col2.markdown("**Action**")

        for code in sorted(list(data.unmatched_batches)):
            col1.write(f"`{code}`")

            key = f"map_batch_{code}"
            stored_action = st.session_state.student_import_mappings['batch'].get(code, "[Select Action]")

            if stored_action == "[USE_NEW]":
                default_display_value = "[-- Use New Batch --]"
            elif stored_action == "[IGNORE]":
                default_display_value = "[-- Ignore These Rows --]"
            else:
                default_display_value = stored_action

            try:
                default_index = options.index(default_display_value)
            except ValueError:
                default_index = 0

            choice = col2.selectbox(f"map_{code}", options=options, key=key, index=default_index, label_visibility="collapsed")

            if choice == "[-- Use New Batch --]":
                st.session_state.student_import_mappings['batch'][code] = "[USE_NEW]"
            elif choice == "[-- Ignore These Rows --]":
                st.session_state.student_import_mappings['batch'][code] = "[IGNORE]"
            else:
                st.session_state.student_import_mappings['batch'][code] = choice

            if choice == "[Select Action]":
                valid = False

        if st.button("‚û°Ô∏è Next", type="primary"):
            if not valid:
                st.error("‚ùå Please select an action for every item.")
            else:
                if data.unmatched_years:
                    st.session_state.student_import_step = 'map_years'
                else:
                    st.session_state.student_import_step = 'ready_to_import'
                st.rerun()

    # State: Map Years
    elif st.session_state.student_import_step == 'map_years':
        st.markdown("#### Step 3: Map Years")
        st.warning(f"‚ö†Ô∏è Your file contains Years that are not in the database for **{selected_degree}**.")

        data: EnrollmentCheckResult = st.session_state.student_import_validation_data
        options = ["[Select Action]"] + data.existing_years + ["[-- Use New Year --]", "[-- Ignore These Rows --]"]

        valid = True
        col1, col2 = st.columns([1, 2])

        col1.markdown("**CSV Value**")
        col2.markdown("**Action**")

        for code in sorted(list(data.unmatched_years)):
            col1.write(f"`{code}`")

            key = f"map_year_{code}"
            stored_action = st.session_state.student_import_mappings['year'].get(code, "[Select Action]")

            if stored_action == "[USE_NEW]":
                default_display_value = "[-- Use New Year --]"
            elif stored_action == "[IGNORE]":
                default_display_value = "[-- Ignore These Rows --]"
            else:
                default_display_value = stored_action

            try:
                default_index = options.index(default_display_value)
            except ValueError:
                default_index = 0

            choice = col2.selectbox(f"map_{code}", options=options, key=key, index=default_index, label_visibility="collapsed")

            if choice == "[-- Use New Year --]":
                st.session_state.student_import_mappings['year'][code] = "[USE_NEW]"
            elif choice == "[-- Ignore These Rows --]":
                st.session_state.student_import_mappings['year'][code] = "[IGNORE]"
            else:
                st.session_state.student_import_mappings['year'][code] = choice

            if choice == "[Select Action]":
                valid = False

        if st.button("‚û°Ô∏è Next", type="primary"):
            if not valid:
                st.error("‚ùå Please select an action for every item.")
            else:
                st.session_state.student_import_step = 'ready_to_import'
                st.rerun()

    # State: Ready to Import (Final Step)
    elif st.session_state.student_import_step == 'ready_to_import':
        st.markdown("#### Step 4: Review and Import")
        st.success("‚úÖ All data is validated and mapped. Ready to import.")

        if 'student_import_df' not in st.session_state or st.session_state.student_import_df is None:
            st.error("‚ùå Session data was lost. Please cancel and start over.")
            return

        with st.expander("üîç Show Final Mappings"):
            st.json(st.session_state.student_import_mappings)

        df_to_import = st.session_state.student_import_df
        mappings = st.session_state.student_import_mappings

        col1, col2 = st.columns(2)

        with col1:
            if st.button("üß™ Dry Run", key="dry_run_students"):
                conn = engine.connect()
                trans = conn.begin()

                try:
                    with st.spinner("Executing Dry Run... (no changes will be made)"):
                        errors, success, skipped = _import_students_with_validation(
                            engine, df_to_import, dry_run=True, mappings=mappings,
                            conn_for_transaction=conn
                        )

                    if errors:
                        st.warning(f"‚ö†Ô∏è Dry run: {success} would succeed, {len(errors)} would fail")
                        st.dataframe(pd.DataFrame(errors)[['row', 'email', 'error']], use_container_width=True)
                    else:
                        st.success(f"‚úÖ Dry run: All {success} records would import successfully")

                    if skipped:
                        st.info(f"‚ÑπÔ∏è {len(skipped)} rows would be skipped due to your 'Ignore' mapping rules.")

                except Exception as e:
                    st.error(f"‚ùå Dry Run Failed: {str(e)}")
                    log.error(f"Dry run failed: {traceback.format_exc()}")

                finally:
                    trans.rollback()
                    conn.close()

        with col2:
            if st.button("üöÄ Execute Import", key="execute_students", type="primary"):
                try:
                    with st.spinner("Executing Import..."):
                        errors, success, skipped = _import_students_with_validation(
                            engine, df_to_import, dry_run=False, mappings=mappings
                        )

                    if errors:
                        st.error(f"‚ùå Import completed with {len(errors)} errors out of {len(df_to_import)} rows")
                        st.download_button(
                            "Download Import Errors",
                            pd.DataFrame(errors).to_csv(index=False),
                            "student_import_errors.csv",
                            "text/csv"
                        )
                    else:
                        st.success(f"‚úÖ Successfully imported {success} record(s)")

                    if skipped:
                        st.info(f"‚ÑπÔ∏è {len(skipped)} rows were skipped due to your 'Ignore' mapping rules.")

                    st.cache_data.clear()
                    _reset_student_import_state()
                    st.rerun()

                except Exception as e:
                    st.error(f"‚ùå Import failed: {str(e)}")
                    log.error(f"Import failed: {traceback.format_exc()}")


# ------------------------------------------------------------------
# UI SECTION 2: STUDENT MOVER
# ------------------------------------------------------------------

def _add_student_mover_section(engine: Engine):
    """
    UI for moving students in bulk from one enrollment (batch) to another.
    """
    st.divider()
    st.subheader("üöö Student Mover")

    if not _show_no_degrees_help(engine, "student moving"):
        return

    st.info("Use this tool to move students between batches or degrees (e.g., at the start of a new academic year).")

    with engine.begin() as conn:
        all_degrees = _active_degrees(conn)

        if not all_degrees:
            st.warning("No degrees found.")
            return

    col1, col2 = st.columns(2)

    with col1:
        st.markdown("**1. Select Students to Move**")
        from_degree = st.selectbox("From Degree", all_degrees, key="move_from_degree")

        with engine.begin() as conn:
            from_batches = _db_get_batches_for_degree(conn, from_degree)

        if not from_batches:
            st.warning(f"No batches found for {from_degree}.")
            return

        from_batch = st.selectbox("From Batch", from_batches, key="move_from_batch")

        if st.button("Get Student List"):
            with engine.begin() as conn:
                df_students = _db_get_students_for_mover(conn, from_degree, from_batch)

            st.session_state.students_to_move_df = df_students

        if df_students.empty:
            st.warning("No students found in this batch.")

        if "students_to_move_df" not in st.session_state:
            st.write("Click 'Get Student List' to begin.")
            return

        st.markdown("**2. Select Students and Destination**")

        edited_df = st.data_editor(
            st.session_state.students_to_move_df,
            key="student_mover_editor",
            use_container_width=True,
            disabled=["Profile ID", "Student ID", "Name", "Email", "Current Year", "Enrollment ID"]
        )

        students_to_move = edited_df[edited_df["Move"] == True]

    with col2:
        st.markdown("**3. Select Destination**")
        to_degree = st.selectbox("To Degree", all_degrees, key="move_to_degree", index=all_degrees.index(from_degree))

        with engine.begin() as conn:
            to_batches = _db_get_batches_for_degree(conn, to_degree)

        to_batch_option = st.radio("Batch Action", ["Move to Existing Batch", "Move to New Batch"], horizontal=True)

        if to_batch_option == "Move to Existing Batch":
            if not to_batches:
                st.error(f"No existing batches for {to_degree}.")
                return

            to_batch = st.selectbox("To Batch", to_batches, key="move_to_batch")
        else:
            to_batch = st.text_input("New Batch Name (e.g., '2022')", key="move_new_batch")

        to_year = st.number_input("Set New Year", min_value=1, max_value=10, value=1, key="move_to_year")

    st.divider()

    if students_to_move.empty:
        st.warning("Select one or more students to move using the 'Move' checkbox.")
        return

    if not to_batch:
        st.warning("Please select or enter a destination batch.")
        return

    st.markdown(f"**Review Plan:**")
    st.warning(f"You are about to move **{len(students_to_move)}** students from **{from_degree} (Batch {from_batch})** "
               f"to **{to_degree} (Batch {to_batch})** and set their year to **{to_year}**.")

    if st.button("üöÄ Execute Move", type="primary"):
        enrollment_ids = students_to_move["Enrollment ID"].tolist()

        try:
            with engine.begin() as conn:
                moved_count = _db_move_students(conn, enrollment_ids, to_degree, to_batch, to_year)

            st.success(f"Successfully moved {moved_count} students!")
            st.cache_data.clear()

            if "students_to_move_df" in st.session_state:
                del st.session_state.students_to_move_df

            st.rerun()

        except Exception as e:
            st.error(f"‚ùå Move Failed: {str(e)}")
            log.error(f"Student move failed: {traceback.format_exc()}")


# ------------------------------------------------------------------
# UI SECTION 3: STUDENT CREDENTIAL EXPORT
# ------------------------------------------------------------------

def _add_student_credential_export_section(engine: Engine):
    """
    UI for exporting student initial credentials.
    """
    st.divider()
    st.subheader("üîë Export Student Initial Credentials")

    with engine.begin() as conn:
        degrees = _active_degrees(conn)

    st.info("This will generate a CSV of usernames and initial passwords for all "
            "students marked for export. This action will also mark them as 'exported'.")

    if st.button("Generate and Download Student Credentials", disabled=(not degrees)):
        try:
            with st.spinner("Generating credential file..."):
                df_creds = _get_student_credentials_to_export(engine)

            if df_creds.empty:
                st.warning("No new student credentials to export.")
                return

            csv = df_creds.to_csv(index=False)

            st.download_button(
                "Download Credentials CSV",
                data=csv,
                file_name="student_initial_credentials.csv",
                mime="text/csv"
            )

        except Exception as e:
            st.error(f"‚ùå Failed to export credentials: {str(e)}")
            log.error(f"Credential export failed: {traceback.format_exc()}")
