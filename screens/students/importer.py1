# app/screens/students/importer.py
# -------------------------------------------------------------------
# All Student Import/Export, Credential, and Mover functions
# ENHANCED WITH INTERACTIVE ERROR MESSAGES
# -------------------------------------------------------------------

from __future__ import annotations

from typing import List, Tuple, Dict, Any, Optional, Set
from dataclasses import dataclass, field
import pandas as pd
import streamlit as st
from sqlalchemy import text as sa_text
from sqlalchemy.engine import Engine, Connection
from collections import defaultdict
import logging

# Import common helpers
from screens.faculty.utils import _safe_int_convert, _handle_error
from screens.faculty.db import _active_degrees

# --- Import from student db.py file ---
from screens.students.db import (
    _ensure_student_username_and_initial_creds,
    _get_student_credentials_to_export,
    _get_existing_enrollment_data,
    _db_get_batches_for_degree,
    _db_get_students_for_mover,
    _db_move_students
)

# Setup logger
log = logging.getLogger(__name__)

# =========================================================================
# ENHANCED ERROR REPORTING SYSTEM - INTERACTIVE ERROR MESSAGES
# =========================================================================

def _format_error_detail(detail: Dict[str, Any]) -> str:
    """
    Formats error detail dictionary into beautiful markdown for Streamlit UI.
    Shows interactive, detailed error information to the user.
    """
    
    msg = f"""
### {detail.get('title', 'Error')}

**Checkpoint:** {detail.get('checkpoint', 'Unknown')}

**What Happened:**  
{detail.get('reason', 'Unknown error')}

**Why This Field Is Required:**
"""
    
    for reason in detail.get('why_required', []):
        msg += f"\n- {reason}"
    
    msg += f"""

**How to Fix It:**  
{detail.get('fix', 'Please check your CSV')}
"""
    
    if 'example' in detail:
        msg += f"\n\n**Example:** `{detail['example']}`"
    
    if 'examples' in detail:
        msg += "\n\n**Suggested Values:**"
        for ex in detail['examples']:
            msg += f"\n- `{ex}`"
    
    if detail.get('available_degrees'):
        degrees = ', '.join(detail['available_degrees'][:5])
        if len(detail['available_degrees']) > 5:
            degrees += f", ... (+{len(detail['available_degrees'])-5} more)"
        msg += f"\n\n**Available Degrees:** `{degrees}`"
    
    if 'common_examples' in detail:
        msg += f"\n\n**Common Examples:** {', '.join(detail['common_examples'])}"
    
    if 'student_id' in detail:
        msg += f"\n\nüí° **Your Student ID:** `{detail['student_id']}`"
    
    if 'provided' in detail:
        msg += f"\n\n‚ö†Ô∏è **You Provided:** `{detail['provided']}`"
    
    if 'explanation' in detail:
        msg += f"\n\nüí° **Note:** {detail['explanation']}"
    
    if detail.get('next_steps'):
        msg += "\n\n**üìã Next Steps:**"
        for step in detail['next_steps']:
            msg += f"\n{step}"
    
    if 'why_failed_first' in detail:
        msg += f"\n\nüî¥ **Why This Failed First:** {detail['why_failed_first']}"
    
    if 'why_failed_second' in detail:
        msg += f"\n\nüü° **Secondary Issue:** {detail['why_failed_second']}"
    
    return msg


# ------------------------------------------------------------------
# Helpers for Stateful Import (Batch/Year Validation)
# ------------------------------------------------------------------

@dataclass
class EnrollmentCheckResult:
    """Holds the data from pre-checking student enrollments."""
    unmatched_batches: Set[str] = field(default_factory=set)
    existing_batches: List[str] = field(default_factory=list)
    unmatched_years: Set[str] = field(default_factory=set)
    existing_years: List[str] = field(default_factory=list)
    ignored_rows: int = 0


def _pre_check_student_enrollments(df: pd.DataFrame, engine: Engine, degree_code: str) -> Tuple[EnrollmentCheckResult, pd.DataFrame]:
    """
    Compares the CSV data against the database for a single degree
    to find unmatched batches and years.
    """
    degree_code_clean = degree_code.strip()

    # 1. Clean and Filter DataFrame
    for col in ['degree_code', 'batch', 'current_year']:
        if col in df.columns:
            df[col] = df[col].astype(str).str.strip().replace('nan', '')

    df_filtered = df[df['degree_code'].str.lower() == degree_code_clean.lower()].copy()
    ignored_rows = len(df) - len(df_filtered)

    if df_filtered.empty:
        raise ValueError(f"No rows found in the CSV for the selected degree '{degree_code_clean}'.")

    # 2. Get unique codes from the *filtered* CSV
    csv_batches = set(df_filtered['batch'].dropna().unique()) - {''}
    csv_years = set(df_filtered['current_year'].dropna().unique()) - {''}

    # 3. Get existing codes from the DB
    existing_data = _get_existing_enrollment_data(engine, degree_code_clean)

    db_batches = set(existing_data['batches'])
    db_years = set(existing_data['years'])

    # 4. Find the mismatches
    result = EnrollmentCheckResult(
        unmatched_batches=csv_batches - db_batches,
        existing_batches=sorted(list(db_batches)),
        unmatched_years=csv_years - db_years,
        existing_years=sorted(list(db_years)),
        ignored_rows=ignored_rows
    )

    return result, df_filtered


def _build_translation_map(
    mappings: Dict[str, Dict[str, str]]
) -> Dict[str, Dict[str, str]]:
    """
    Converts the raw UI mappings into a clean translation map
    for the import function.
    """
    translation_map = {}
    for aff_type, type_mappings in mappings.items():
        translation_map[aff_type] = {}
        for code, action in type_mappings.items():
            if action == "[USE_NEW]":
                translation_map[aff_type][code] = code
            else:
                translation_map[aff_type][code] = action

    return translation_map


# ------------------------------------------------------------------
# Main Import Logic (with Interactive Error Messages)
# ------------------------------------------------------------------

def _show_no_degrees_help(engine: Engine, context: str = "student operations"):
    """
    Shows a helpful setup guide when no degrees exist.
    Returns True if degrees exist, False otherwise.
    """
    with engine.begin() as conn:
        degrees = _active_degrees(conn)
        if degrees:
            return True

    # No degrees found - show setup guide
    st.warning(f"‚ö†Ô∏è No degrees found. You need to set up degrees before performing {context}.")
    st.markdown("""
### üöÄ Getting Started

To import students, you need to first create the academic structure:

1. **Create Degrees** (e.g., BTech, MTech, MBA)
2. *(Optional)* Create Programs and Branches
3. **Import Students** using the CSV template
""")

    with st.expander("‚ûï Quick Create Your First Degree", expanded=True):
        st.info("Create a degree to unlock student import functionality.")
        col1, col2 = st.columns(2)

        with col1:
            degree_code = st.text_input(
                "Degree Code*",
                placeholder="e.g., BTech, MTech",
                key=f"quick_degree_code_{context}"
            )

        with col2:
            degree_name = st.text_input(
                "Degree Name (optional)",
                placeholder="e.g., Bachelor of Technology",
                key=f"quick_degree_name_{context}"
            )

        if st.button("‚ú® Create Degree", type="primary", key=f"create_degree_{context}"):
            if not degree_code or not degree_code.strip():
                st.error("‚ùå Degree code is required")
            else:
                try:
                    with engine.begin() as conn:
                        # Check if degree already exists
                        existing = conn.execute(sa_text(
                            "SELECT 1 FROM degrees WHERE LOWER(code) = LOWER(:code)"
                        ), {"code": degree_code.strip()}).fetchone()

                        if existing:
                            st.error(f"‚ùå Degree '{degree_code}' already exists")
                        else:
                            conn.execute(sa_text("""
                                INSERT INTO degrees (code, name, active, sort_order, created_at, updated_at)
                                VALUES (:code, :name, 1, 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
                            """), {
                                "code": degree_code.strip(),
                                "name": degree_name.strip() or degree_code.strip()
                            })
                            st.success(f"‚úÖ Created degree: **{degree_code}**")
                            st.cache_data.clear()
                            st.balloons()
                            st.rerun()
                except Exception as e:
                    st.error(f"‚ùå Failed to create degree: {e}")
                    log.error(f"Degree creation failed: {e}")

    st.divider()
    st.info("üí° **Alternative:** If you have a dedicated Degrees management page, you can create degrees there with more options.")
    return False


def _import_students_with_validation(
    engine: Engine,
    df: pd.DataFrame,
    dry_run: bool,
    mappings: Optional[Dict[str, Dict[str, str]]] = None,
    conn_for_transaction: Optional[Connection] = None
) -> Tuple[List[Dict[str, Any]], int, List[Dict[str, Any]]]:
    """
    Import combined student profiles and enrollments with validation and interactive error messages.
    RETURNS: (errors, success_count, skipped_rows)
    """
    df.columns = [col.lower().strip().replace(' ', '_') for col in df.columns]
    errors: List[Dict[str, Any]] = []
    skipped_rows: List[Dict[str, Any]] = []
    success_count = 0
    translation_map = _build_translation_map(mappings) if mappings else {}

    # Metadata fetch
    with engine.begin() as meta_conn:
        all_degrees = _active_degrees(meta_conn)

    # Transaction logic
    if conn_for_transaction:
        conn = conn_for_transaction
        trans = conn.begin_nested()
        should_close = False
    else:
        conn = engine.connect()
        trans = conn.begin()
        should_close = True

    try:
        for idx, row in df.iterrows():
            row_num = idx + 2
            try:
                # ============================================================
                # CHECKPOINT 2: VALIDATE PROFILE FIELDS
                # ============================================================

                email = str(row.get('email', '')).strip().lower()
                student_id = str(row.get('student_id', '')).strip()
                name = str(row.get('name', '')).strip()

                # Check for missing name
                if not name:
                    error_detail = {
                        'title': f'‚ùå MISSING NAME (Row {row_num})',
                        'checkpoint': 'Profile Validation (Checkpoint 2)',
                        'reason': 'The "name" column is empty.',
                        'why_required': [
                            '‚úì Identify who this student is',
                            '‚úì Store in student profile',
                            '‚úì Generate credentials'
                        ],
                        'fix': 'Add the student\'s full name to the CSV.',
                        'example': 'ANSARI MISBA'
                    }
                    error_display = _format_error_detail(error_detail)
                    st.error(error_display)
                    errors.append({
                        'row': row_num,
                        'email': email,
                        'error': 'Missing name',
                        'detail': error_detail
                    })
                    continue

                # Check for missing email
                if not email:
                    error_detail = {
                        'title': f'‚ùå MISSING EMAIL (Row {row_num})',
                        'checkpoint': 'Profile Validation (Checkpoint 2)',
                        'reason': 'The "email" column is empty.',
                        'why_required': [
                            '‚úì Send credentials to student',
                            '‚úì System notifications and password recovery',
                            '‚úì Unique identifier in database',
                            '‚úì Database constraint: email TEXT UNIQUE NOT NULL'
                        ],
                        'fix': 'Generate institutional email: s{student_id}@institution.edu',
                        'examples': [
                            f's{student_id}@institution.edu',
                            f'{student_id}@institution.edu',
                            f'student{student_id}@institution.edu'
                        ],
                        'student_id': student_id,
                        'why_failed_first': 'Email is the FIRST field checked in validation'
                    }
                    error_display = _format_error_detail(error_detail)
                    st.error(error_display)
                    errors.append({
                        'row': row_num,
                        'email': email,
                        'error': 'Missing email',
                        'detail': error_detail
                    })
                    continue

                # Check for missing student_id
                if not student_id:
                    error_detail = {
                        'title': f'‚ùå MISSING STUDENT ID (Row {row_num})',
                        'checkpoint': 'Profile Validation (Checkpoint 2)',
                        'reason': 'The "student_id" column is empty.',
                        'why_required': [
                            '‚úì Unique identifier for student',
                            '‚úì Links all student records',
                            '‚úì Database constraint: student_id TEXT UNIQUE'
                        ],
                        'fix': 'Add the student ID number.',
                        'example': '202101'
                    }
                    error_display = _format_error_detail(error_detail)
                    st.error(error_display)
                    errors.append({
                        'row': row_num,
                        'email': email,
                        'error': 'Missing student_id',
                        'detail': error_detail
                    })
                    continue

                # Profile fields OK - insert profile
                profile_id = conn.execute(sa_text(
                    "SELECT id FROM student_profiles WHERE student_id = :sid"
                ), {"sid": student_id}).fetchone()

                if profile_id:
                    profile_id = profile_id[0]
                    conn.execute(sa_text("""
                        UPDATE student_profiles
                        SET name = :name, email = :email, phone = :phone, status = :status,
                        updated_at = CURRENT_TIMESTAMP
                        WHERE id = :id
                    """), {
                        "name": name, "email": email, "phone": row.get('phone'),
                        "status": row.get('status', 'active'), "id": profile_id
                    })
                else:
                    res = conn.execute(sa_text("""
                        INSERT INTO student_profiles (name, email, student_id, phone, status)
                        VALUES (:name, :email, :sid, :phone, :status)
                        RETURNING id
                    """), {
                        "name": name, "email": email, "sid": student_id,
                        "phone": row.get('phone'), "status": row.get('status', 'active')
                    })
                    profile_id = res.fetchone()[0]

                # Ensure Credentials Exist
                _ensure_student_username_and_initial_creds(
                    conn, profile_id, email, name, student_id
                )

                # ============================================================
                # CHECKPOINT 4: VALIDATE ENROLLMENT FIELDS
                # ============================================================

                degree_code = str(row.get('degree_code', '')).strip()

                # Check for missing degree_code
                if not degree_code:
                    error_detail = {
                        'title': f'‚ùå MISSING DEGREE CODE (Row {row_num})',
                        'checkpoint': 'Enrollment Validation (Checkpoint 4)',
                        'reason': 'The "degree_code" column is empty.',
                        'why_required': [
                            '‚úì Student must be in a degree program',
                            '‚úì Required for enrollment record',
                            '‚úì Database constraint: degree_code TEXT NOT NULL'
                        ],
                        'fix': 'Add a valid degree code.',
                        'available_degrees': sorted(list(all_degrees)),
                        'why_failed_second': 'Secondary issue: Would fail here if email was fixed'
                    }
                    error_display = _format_error_detail(error_detail)
                    st.error(error_display)
                    errors.append({
                        'row': row_num,
                        'email': email,
                        'error': 'Missing degree_code',
                        'detail': error_detail
                    })
                    continue

                # Check if degree exists
                if degree_code not in all_degrees:
                    error_detail = {
                        'title': f'‚ùå DEGREE "{degree_code}" NOT FOUND (Row {row_num})',
                        'checkpoint': 'Enrollment Validation (Checkpoint 5)',
                        'reason': f'Degree "{degree_code}" does not exist.',
                        'why_required': [
                            '‚úì Database enforces referential integrity',
                            '‚úì Students can only enroll in existing degrees'
                        ],
                        'fix': 'Use a valid degree code.',
                        'available_degrees': sorted(list(all_degrees)),
                        'provided': degree_code
                    }
                    error_display = _format_error_detail(error_detail)
                    st.error(error_display)
                    errors.append({
                        'row': row_num,
                        'email': email,
                        'error': f'Degree "{degree_code}" not found',
                        'detail': error_detail
                    })
                    continue

                batch = str(row.get('batch', '')).strip()
                current_year = str(row.get('current_year', '')).strip()

                # Check for missing batch
                if not batch:
                    error_detail = {
                        'title': f'‚ùå MISSING BATCH (Row {row_num})',
                        'checkpoint': 'Enrollment Validation (Checkpoint 4)',
                        'reason': 'The "batch" column is empty.',
                        'why_required': [
                            '‚úì Track academic cohort/entry year',
                            '‚úì Group students by when they started',
                            '‚úì Required for enrollment'
                        ],
                        'fix': 'Add batch/entry year (e.g., 2021, 2022).',
                        'examples': ['2021', '2022', '2023'],
                        'explanation': 'Batch identifies which cohort the student belongs to (when they started their program)'
                    }
                    error_display = _format_error_detail(error_detail)
                    st.error(error_display)
                    errors.append({
                        'row': row_num,
                        'email': email,
                        'error': 'Missing batch',
                        'detail': error_detail
                    })
                    continue

                # Check for missing current_year
                if not current_year:
                    error_detail = {
                        'title': f'‚ùå MISSING CURRENT YEAR (Row {row_num})',
                        'checkpoint': 'Enrollment Validation (Checkpoint 4)',
                        'reason': 'The "current_year" column is empty.',
                        'why_required': [
                            '‚úì Track student progress in degree',
                            '‚úì Identify year in program (1st, 2nd, etc.)',
                            '‚úì Required for enrollment'
                        ],
                        'fix': 'Add year in program as number (1-5 for 5-year degree)',
                        'examples': ['1', '2', '3', '4', '5'],
                        'explanation': 'Current year shows how far through their degree they are (1=1st year, 5=5th year)'
                    }
                    error_display = _format_error_detail(error_detail)
                    st.error(error_display)
                    errors.append({
                        'row': row_num,
                        'email': email,
                        'error': 'Missing current_year',
                        'detail': error_detail
                    })
                    continue

                # Apply mappings
                mapped_batch = translation_map.get('batch', {}).get(batch, batch)
                mapped_year = translation_map.get('year', {}).get(current_year, current_year)

                # Check for [IGNORE]
                if mapped_batch == "[IGNORE]" or mapped_year == "[IGNORE]":
                    log.debug(f"Row {row_num}: Ignoring enrollment due to user mapping.")
                    skipped_rows.append({
                        "row": row_num, "email": email, "reason": "Ignored by user mapping rule."
                    })
                    continue

                program_code = str(row.get('program_code', '')).strip() or None
                branch_code = str(row.get('branch_code', '')).strip() or None

                # Upsert Enrollment
                enrollment_id = conn.execute(sa_text("""
                    SELECT id FROM student_enrollments
                    WHERE student_profile_id = :pid AND degree_code = :degree AND batch = :batch
                """), {
                    "pid": profile_id, "degree": degree_code, "batch": mapped_batch
                }).fetchone()

                if enrollment_id:
                    conn.execute(sa_text("""
                        UPDATE student_enrollments
                        SET program_code = :prog, branch_code = :branch,
                        current_year = :year, enrollment_status = :status,
                        updated_at = CURRENT_TIMESTAMP
                        WHERE id = :id
                    """), {
                        "prog": program_code, "branch": branch_code,
                        "year": mapped_year, "status": row.get('enrollment_status', 'active'),
                        "id": enrollment_id[0]
                    })
                else:
                    conn.execute(sa_text("""
                        INSERT INTO student_enrollments (
                        student_profile_id, degree_code, program_code, branch_code,
                        batch, current_year, enrollment_status, is_primary
                        ) VALUES (
                        :pid, :degree, :prog, :branch,
                        :batch, :year, :status, 1
                        )
                    """), {
                        "pid": profile_id, "degree": degree_code, "prog": program_code, "branch": branch_code,
                        "batch": mapped_batch, "year": mapped_year,
                        "status": row.get('enrollment_status', 'active')
                    })

                success_count += 1

            except Exception as e:
                error_detail = {
                    'title': f'‚ùå UNEXPECTED ERROR (Row {row_num})',
                    'checkpoint': 'Exception Handler',
                    'reason': str(e),
                    'why_required': ['This is an internal error that shouldn\'t normally occur'],
                    'fix': 'Contact support or check your data format'
                }
                error_display = _format_error_detail(error_detail)
                st.error(error_display)
                errors.append({
                    'row': row_num,
                    'email': str(row.get('email', '')).strip().lower(),
                    'error': str(e),
                    'detail': error_detail
                })

        if dry_run:
            trans.rollback()
        else:
            trans.commit()

    except Exception:
        if trans:
            trans.rollback()
        raise

    finally:
        if should_close:
            conn.close()

    return errors, success_count, skipped_rows


# ------------------------------------------------------------------
# STATEFUL IMPORT UI
# ------------------------------------------------------------------

def _reset_student_import_state():
    """Resets the session state for the student import wizard."""
    st.session_state.student_import_step = 'initial'
    st.session_state.student_import_mappings = {}
    st.session_state.student_import_validation_data = None
    st.session_state.student_import_df = None
    log.debug("Resetting student import state.")


# DEBUG VERSION OF _add_student_import_export_section
# Add this to your importer.py, replacing the existing function

def _add_student_import_export_section(engine: Engine):
    """
    UI for managing student import/export, including stateful validation for Batches and Years.
    DEBUG VERSION WITH COMPREHENSIVE LOGGING
    """
    
    st.divider()
    st.subheader("üî•üì§ Combined Student Import/Export")
    
    # ====== DEBUG: Show that function is called ======
    st.write("üîç **DEBUG: Function _add_student_import_export_section called**")
    
    if not _show_no_degrees_help(engine, "student import"):
        st.write("üîç **DEBUG: _show_no_degrees_help returned False - no degrees found**")
        return

    # State Initialization
    if 'student_import_step' not in st.session_state:
        _reset_student_import_state()
        st.write("üîç **DEBUG: Initialized session state**")

    # Select Degree
    with engine.begin() as conn:
        degrees = _active_degrees(conn)
        st.write(f"üîç **DEBUG: Found {len(degrees)} degrees: {degrees}**")

        if not degrees:
            st.error("‚ùå No degrees available. Please create degrees first.")
            return

    if st.session_state.get('student_import_degree'):
        selected_degree = st.session_state.student_import_degree
        st.info(f"üìã **Selected Degree:** `{selected_degree}`")
    else:
        selected_degree_raw = st.selectbox("Select Degree for Student Import", options=degrees, key="degree_selector_student")

        if st.button("Confirm Degree Selection", type="primary"):
            st.session_state.student_import_degree = selected_degree_raw.strip()
            st.write(f"üîç **DEBUG: Selected degree: {selected_degree_raw}**")
            st.rerun()

        st.warning("‚ö†Ô∏è Please confirm your degree selection to proceed with import.")
        return

    # Export Section
    with st.expander("üì• Export Student Data / Templates"):
        st.download_button(
            label="Download Combined Student Template",
            data="name,email,student_id,phone,status,degree_code,program_code,branch_code,batch,current_year,enrollment_status",
            file_name="student_combined_template.csv",
            mime="text/csv"
        )

    # File Uploader
    st.markdown("### üì§ Import Student Data")
    up = st.file_uploader("Upload Combined Student CSV", type="csv", key="student_uploader")

    if st.session_state.student_import_step != 'initial':
        if st.button("üîÑ Cancel Import & Start Over", key="cancel_student_import"):
            _reset_student_import_state()
            st.rerun()

    st.divider()

    # State: Initial (Validation)
    if st.session_state.student_import_step == 'initial':
        st.markdown("#### Step 1: Validate File")
        st.write(f"üîç **DEBUG: Current step = 'initial'**")

        if not up:
            st.warning("Please upload a CSV file to begin.")
            if 'student_import_df' in st.session_state:
                _reset_student_import_state()
            st.write("üîç **DEBUG: No file uploaded yet**")
            return

        st.write(f"üîç **DEBUG: File uploaded: {up.name}**")

        if st.button("üîç Validate File", type="primary"):
            st.write("üîç **DEBUG: Validate button clicked**")
            
            try:
                up.seek(0)
                df = pd.read_csv(up)
                st.write(f"üîç **DEBUG: CSV read successfully, {len(df)} rows, columns: {list(df.columns)}**")

                with st.spinner("Validating CSV for new batches and years..."):
                    st.write(f"üîç **DEBUG: Calling _pre_check_student_enrollments for degree: {selected_degree}**")
                    validation_data, filtered_df = _pre_check_student_enrollments(df, engine, selected_degree)
                    st.write(f"üîç **DEBUG: Validation complete - filtered_df rows: {len(filtered_df)}**")
                    st.write(f"üîç **DEBUG: Unmatched batches: {validation_data.unmatched_batches}**")
                    st.write(f"üîç **DEBUG: Unmatched years: {validation_data.unmatched_years}**")

                st.session_state.student_import_validation_data = validation_data
                st.session_state.student_import_df = filtered_df
                st.session_state.student_import_mappings = {"batch": {}, "year": {}}

                if validation_data.ignored_rows > 0:
                    st.info(f"‚úÖ Found {len(filtered_df)} rows for degree '{selected_degree}'. "
                            f"{validation_data.ignored_rows} rows for other degrees will be ignored.")

                if validation_data.unmatched_batches:
                    st.write("üîç **DEBUG: Moving to map_batches step**")
                    st.session_state.student_import_step = 'map_batches'
                elif validation_data.unmatched_years:
                    st.write("üîç **DEBUG: Moving to map_years step**")
                    st.session_state.student_import_step = 'map_years'
                else:
                    st.write("üîç **DEBUG: Moving to ready_to_import step**")
                    st.session_state.student_import_step = 'ready_to_import'

                st.rerun()

            except Exception as e:
                st.error(f"‚ùå Validation Failed: {str(e)}")
                st.write(f"üîç **DEBUG: Exception type: {type(e).__name__}**")
                st.write(f"üîç **DEBUG: Full traceback:**")
                import traceback
                st.code(traceback.format_exc())
                _reset_student_import_state()

    # State: Map Batches
    elif st.session_state.student_import_step == 'map_batches':
        st.write("üîç **DEBUG: Current step = 'map_batches'**")
        st.markdown("#### Step 2: Map Batches")
        st.warning(f"‚ö†Ô∏è Your file contains Batches that are not in the database for **{selected_degree}**.")

        data: EnrollmentCheckResult = st.session_state.student_import_validation_data
        st.write(f"üîç **DEBUG: Unmatched batches: {data.unmatched_batches}**")
        
        options = ["[Select Action]"] + data.existing_batches + ["[-- Use New Batch --]", "[-- Ignore These Rows --]"]

        valid = True
        col1, col2 = st.columns([1, 2])

        col1.markdown("**CSV Value**")
        col2.markdown("**Action**")

        for code in sorted(list(data.unmatched_batches)):
            col1.write(f"`{code}`")

            key = f"map_batch_{code}"
            stored_action = st.session_state.student_import_mappings['batch'].get(code, "[Select Action]")

            if stored_action == "[USE_NEW]":
                default_display_value = "[-- Use New Batch --]"
            elif stored_action == "[IGNORE]":
                default_display_value = "[-- Ignore These Rows --]"
            else:
                default_display_value = stored_action

            try:
                default_index = options.index(default_display_value)
            except ValueError:
                default_index = 0

            choice = col2.selectbox(f"map_{code}", options=options, key=key, index=default_index, label_visibility="collapsed")

            if choice == "[-- Use New Batch --]":
                st.session_state.student_import_mappings['batch'][code] = "[USE_NEW]"
            elif choice == "[-- Ignore These Rows --]":
                st.session_state.student_import_mappings['batch'][code] = "[IGNORE]"
            else:
                st.session_state.student_import_mappings['batch'][code] = choice

            if choice == "[Select Action]":
                valid = False

        if st.button("‚û°Ô∏è Next", type="primary"):
            if not valid:
                st.error("‚ùå Please select an action for every item.")
            else:
                if data.unmatched_years:
                    st.write("üîç **DEBUG: Moving to map_years**")
                    st.session_state.student_import_step = 'map_years'
                else:
                    st.write("üîç **DEBUG: Moving to ready_to_import**")
                    st.session_state.student_import_step = 'ready_to_import'
                st.rerun()

    # State: Map Years
    elif st.session_state.student_import_step == 'map_years':
        st.write("üîç **DEBUG: Current step = 'map_years'**")
        st.markdown("#### Step 3: Map Years")
        st.warning(f"‚ö†Ô∏è Your file contains Years that are not in the database for **{selected_degree}**.")

        data: EnrollmentCheckResult = st.session_state.student_import_validation_data
        st.write(f"üîç **DEBUG: Unmatched years: {data.unmatched_years}**")
        
        options = ["[Select Action]"] + data.existing_years + ["[-- Use New Year --]", "[-- Ignore These Rows --]"]

        valid = True
        col1, col2 = st.columns([1, 2])

        col1.markdown("**CSV Value**")
        col2.markdown("**Action**")

        for code in sorted(list(data.unmatched_years)):
            col1.write(f"`{code}`")

            key = f"map_year_{code}"
            stored_action = st.session_state.student_import_mappings['year'].get(code, "[Select Action]")

            if stored_action == "[USE_NEW]":
                default_display_value = "[-- Use New Year --]"
            elif stored_action == "[IGNORE]":
                default_display_value = "[-- Ignore These Rows --]"
            else:
                default_display_value = stored_action

            try:
                default_index = options.index(default_display_value)
            except ValueError:
                default_index = 0

            choice = col2.selectbox(f"map_{code}", options=options, key=key, index=default_index, label_visibility="collapsed")

            if choice == "[-- Use New Year --]":
                st.session_state.student_import_mappings['year'][code] = "[USE_NEW]"
            elif choice == "[-- Ignore These Rows --]":
                st.session_state.student_import_mappings['year'][code] = "[IGNORE]"
            else:
                st.session_state.student_import_mappings['year'][code] = choice

            if choice == "[Select Action]":
                valid = False

        if st.button("‚û°Ô∏è Next", type="primary"):
            if not valid:
                st.error("‚ùå Please select an action for every item.")
            else:
                st.write("üîç **DEBUG: Moving to ready_to_import**")
                st.session_state.student_import_step = 'ready_to_import'
                st.rerun()

    # State: Ready to Import (Final Step)
    elif st.session_state.student_import_step == 'ready_to_import':
        st.write("üîç **DEBUG: Current step = 'ready_to_import'**")
        st.markdown("#### Step 4: Review and Import")
        st.success("‚úÖ All data is validated and mapped. Ready to import.")

        if 'student_import_df' not in st.session_state or st.session_state.student_import_df is None:
            st.error("‚ùå Session data was lost. Please cancel and start over.")
            st.write("üîç **DEBUG: student_import_df not in session state**")
            return

        with st.expander("üîç Show Final Mappings"):
            st.json(st.session_state.student_import_mappings)

        df_to_import = st.session_state.student_import_df
        mappings = st.session_state.student_import_mappings

        st.write(f"üîç **DEBUG: df_to_import shape: {df_to_import.shape}**")
        st.write(f"üîç **DEBUG: mappings: {mappings}**")

        col1, col2 = st.columns(2)

        with col1:
            if st.button("üß™ Dry Run", key="dry_run_students"):
                st.write("üîç **DEBUG: Dry Run button clicked**")
                conn = engine.connect()
                trans = conn.begin()

                try:
                    with st.spinner("Executing Dry Run... (no changes will be made)"):
                        st.write("üîç **DEBUG: Calling _import_students_with_validation (dry_run=True)**")
                        errors, success, skipped = _import_students_with_validation(
                            engine, df_to_import, dry_run=True, mappings=mappings,
                            conn_for_transaction=conn
                        )
                        st.write(f"üîç **DEBUG: Dry run complete - success: {success}, errors: {len(errors)}, skipped: {len(skipped)}**")

                    if errors:
                        st.warning(f"‚ö†Ô∏è Dry run: {success} would succeed, {len(errors)} would fail")
                        st.dataframe(pd.DataFrame(errors)[['row', 'email', 'error']], use_container_width=True)
                    else:
                        st.success(f"‚úÖ Dry run: All {success} records would import successfully")

                    if skipped:
                        st.info(f"‚ÑπÔ∏è {len(skipped)} rows would be skipped due to your 'Ignore' mapping rules.")

                except Exception as e:
                    st.error(f"‚ùå Dry Run Failed: {str(e)}")
                    st.write(f"üîç **DEBUG: Exception type: {type(e).__name__}**")
                    st.code(traceback.format_exc())

                finally:
                    trans.rollback()
                    conn.close()

        with col2:
            if st.button("üöÄ Execute Import", key="execute_students", type="primary"):
                st.write("üîç **DEBUG: Execute Import button clicked**")
                
                try:
                    with st.spinner("Executing Import..."):
                        st.write("üîç **DEBUG: Calling _import_students_with_validation (dry_run=False)**")
                        errors, success, skipped = _import_students_with_validation(
                            engine, df_to_import, dry_run=False, mappings=mappings
                        )
                        st.write(f"üîç **DEBUG: Import complete - success: {success}, errors: {len(errors)}, skipped: {len(skipped)}**")

                    if errors:
                        st.error(f"‚ùå Import completed with {len(errors)} errors out of {len(df_to_import)} rows")
                        st.download_button(
                            "Download Import Errors",
                            pd.DataFrame(errors).to_csv(index=False),
                            "student_import_errors.csv",
                            "text/csv"
                        )
                    else:
                        st.success(f"‚úÖ Successfully imported {success} record(s)")

                    if skipped:
                        st.info(f"‚ÑπÔ∏è {len(skipped)} rows were skipped due to your 'Ignore' mapping rules.")

                    st.cache_data.clear()
                    _reset_student_import_state()
                    st.rerun()

                except Exception as e:
                    st.error(f"‚ùå Import failed: {str(e)}")
                    st.write(f"üîç **DEBUG: Exception type: {type(e).__name__}**")
                    st.code(traceback.format_exc())

# ------------------------------------------------------------------
# UI SECTION 2: STUDENT MOVER
# ------------------------------------------------------------------

def _add_student_mover_section(engine: Engine):
    """
    UI for moving students in bulk from one enrollment (batch) to another.
    """
    st.divider()
    st.subheader("üöö Student Mover")

    if not _show_no_degrees_help(engine, "student moving"):
        return

    st.info("Use this tool to move students between batches or degrees (e.g., at the start of a new academic year).")

    with engine.begin() as conn:
        all_degrees = _active_degrees(conn)

        if not all_degrees:
            st.warning("No degrees found.")
            return

    col1, col2 = st.columns(2)

    with col1:
        st.markdown("**1. Select Students to Move**")
        from_degree = st.selectbox("From Degree", all_degrees, key="move_from_degree")

        with engine.begin() as conn:
            from_batches = _db_get_batches_for_degree(conn, from_degree)

        if not from_batches:
            st.warning(f"No batches found for {from_degree}.")
            return

        from_batch = st.selectbox("From Batch", from_batches, key="move_from_batch")

        if st.button("Get Student List"):
            with engine.begin() as conn:
                df_students = _db_get_students_for_mover(conn, from_degree, from_batch)

            st.session_state.students_to_move_df = df_students

        if df_students.empty:
            st.warning("No students found in this batch.")

        if "students_to_move_df" not in st.session_state:
            st.write("Click 'Get Student List' to begin.")
            return

        st.markdown("**2. Select Students and Destination**")

        edited_df = st.data_editor(
            st.session_state.students_to_move_df,
            key="student_mover_editor",
            use_container_width=True,
            disabled=["Profile ID", "Student ID", "Name", "Email", "Current Year", "Enrollment ID"]
        )

        students_to_move = edited_df[edited_df["Move"] == True]

    with col2:
        st.markdown("**3. Select Destination**")
        to_degree = st.selectbox("To Degree", all_degrees, key="move_to_degree", index=all_degrees.index(from_degree))

        with engine.begin() as conn:
            to_batches = _db_get_batches_for_degree(conn, to_degree)

        to_batch_option = st.radio("Batch Action", ["Move to Existing Batch", "Move to New Batch"], horizontal=True)

        if to_batch_option == "Move to Existing Batch":
            if not to_batches:
                st.error(f"No existing batches for {to_degree}.")
                return

            to_batch = st.selectbox("To Batch", to_batches, key="move_to_batch")
        else:
            to_batch = st.text_input("New Batch Name (e.g., '2022')", key="move_new_batch")

        to_year = st.number_input("Set New Year", min_value=1, max_value=10, value=1, key="move_to_year")

    st.divider()

    if students_to_move.empty:
        st.warning("Select one or more students to move using the 'Move' checkbox.")
        return

    if not to_batch:
        st.warning("Please select or enter a destination batch.")
        return

    st.markdown(f"**Review Plan:**")
    st.warning(f"You are about to move **{len(students_to_move)}** students from **{from_degree} (Batch {from_batch})** "
               f"to **{to_degree} (Batch {to_batch})** and set their year to **{to_year}**.")

    if st.button("üöÄ Execute Move", type="primary"):
        enrollment_ids = students_to_move["Enrollment ID"].tolist()

        try:
            with engine.begin() as conn:
                moved_count = _db_move_students(conn, enrollment_ids, to_degree, to_batch, to_year)

            st.success(f"Successfully moved {moved_count} students!")
            st.cache_data.clear()

            if "students_to_move_df" in st.session_state:
                del st.session_state.students_to_move_df

            st.rerun()

        except Exception as e:
            _handle_error(e, "Move Failed")


# ------------------------------------------------------------------
# UI SECTION 3: STUDENT CREDENTIAL EXPORT
# ------------------------------------------------------------------

def _add_student_credential_export_section(engine: Engine):
    """
    UI for exporting student initial credentials.
    """
    st.divider()
    st.subheader("üîë Export Student Initial Credentials")

    with engine.begin() as conn:
        degrees = _active_degrees(conn)

    st.info("This will generate a CSV of usernames and initial passwords for all "
            "students marked for export. This action will also mark them as 'exported'.")

    if st.button("Generate and Download Student Credentials", disabled=(not degrees)):
        try:
            with st.spinner("Generating credential file..."):
                df_creds = _get_student_credentials_to_export(engine)

            if df_creds.empty:
                st.warning("No new student credentials to export.")
                return

            csv = df_creds.to_csv(index=False)

            st.download_button(
                "Download Credentials CSV",
                data=csv,
                file_name="student_initial_credentials.csv",
                mime="text/csv"
            )

        except Exception as e:
            _handle_error(e, "Failed to export credentials")
